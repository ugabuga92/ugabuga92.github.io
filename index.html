<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pip-Boy 3000 Mk-V - Open World RPG</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        /* --- PIP-BOY CORE STYLES --- */
        :root {
            --pip-green: #39ff14; 
            --pip-dim: #1a4d1a;
            --pip-dark: #0a0f0a;
            --pip-bg: #050505;
            --pip-shadow: 0 0 10px rgba(57, 255, 20, 0.4);
            
            /* Wasteland Map Colors */
            --color-arid: #4a3d34; 
            --color-path: #8b7d6b; 
            --color-rock: #5c544d; 
            --color-water: #224f80; 
            --color-city: #7a661f; 
            --color-fog: #000000;
        }

        body {
            background-color: #000;
            color: var(--pip-green);
            font-family: 'VT323', monospace;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            user-select: none;
        }

        .pip-screen {
            background-color: var(--pip-bg);
            border: 2px solid var(--pip-green);
            box-shadow: var(--pip-shadow);
            width: 100%;
            height: 100%;
            max-width: 800px; /* Max width of the Pip-Boy interface */
            max-height: 600px; /* Max height of the Pip-Boy interface */
            display: flex;
            flex-direction: column;
        }
        
        .pip-header, .pip-footer {
            background-color: var(--pip-dark);
            border-bottom: 1px solid var(--pip-dim);
            padding: 8px 12px;
            text-align: center;
            font-size: 1.25rem;
            text-shadow: 0 0 5px var(--pip-green);
        }

        .pip-footer {
            border-top: 1px solid var(--pip-dim);
            border-bottom: none;
        }

        .pip-nav button {
            background-color: var(--pip-dim);
            border: 1px solid var(--pip-green);
            padding: 4px 8px;
            margin: 0 4px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.1s;
        }
        
        .pip-nav button:hover {
            background-color: var(--pip-green);
            color: var(--pip-dark);
            box-shadow: 0 0 8px var(--pip-green);
        }

        .pip-nav button.active {
            background-color: var(--pip-green);
            color: var(--pip-dark);
            font-weight: bold;
            text-shadow: none;
        }

        .log-entry {
            border-bottom: 1px dashed var(--pip-dim);
            padding: 2px 0;
            font-size: 0.9rem;
        }
        
        .map-canvas {
            background-color: var(--color-fog); /* Start mit Nebel */
        }
        
        .pip-content {
            flex-grow: 1;
            overflow: hidden;
            display: flex;
        }
        
        /* Specific view styles */
        #stat-view, #item-view, #map-view, #combat-view, #log-view, #wiki-view {
            padding: 1rem;
            overflow-y: auto;
            display: none;
            flex-grow: 1;
        }
        
        #map-view {
            padding: 0;
            display: flex;
            flex-direction: column;
        }
        
        .stat-line, .item-line {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }
        
        .stat-line button {
            padding: 0 5px;
            border: 1px solid var(--pip-green);
            cursor: pointer;
            margin-left: 5px;
            background-color: var(--pip-dim);
        }
        
        .stat-line button:hover {
            background-color: var(--pip-green);
            color: var(--pip-dark);
        }

        .pip-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 50;
            display: none;
            justify-content: center;
            align-items: center;
        }

    </style>
</head>
<body>

    <div id="pip-screen" class="pip-screen relative">
        <div class="pip-header flex justify-between items-center">
            <span id="player-name-display" class="uppercase">WASTELANDER</span>
            <div class="text-right">
                <span id="health-display">HP: 100/100</span> | 
                <span id="caps-display">CAPS: 0</span>
            </div>
        </div>
        
        <div class="pip-nav flex justify-center py-2 border-b border-t border-pip-dim bg-pip-dark">
            <button onclick="switchView('stat')" id="nav-stat" class="active">STAT</button>
            <button onclick="switchView('item')" id="nav-item">ITEM</button>
            <button onclick="switchView('map')" id="nav-map">MAP</button>
            <button onclick="switchView('log')" id="nav-log">LOG</button>
            <button onclick="showWiki()" id="nav-wiki">WIKI</button>
        </div>
        
        <div class="pip-content">
            
            <div id="stat-view" class="bg-pip-bg overflow-y-auto">
                <h2 class="text-xl border-b border-pip-dim mb-4">S.P.E.C.I.A.L. & Skills</h2>
                <div id="special-points-container" class="mb-4"></div>
                <div id="stat-list">
                    </div>
                <div class="mt-6 border-t border-pip-dim pt-4">
                    <h3 class="text-lg">Zusätzliche Infos:</h3>
                    <p>Level: <span id="level-display">1</span></p>
                    <p>Erfahrung: <span id="exp-display">0</span> / <span id="exp-needed-display">100</span></p>
                    <p>Stat-Punkte: <span id="stat-points-display" class="font-bold">0</span></p>
                </div>
            </div>
            
            <div id="item-view" class="bg-pip-bg overflow-y-auto">
                <h2 class="text-xl border-b border-pip-dim mb-4">INVENTAR</h2>
                <div id="item-list" class="grid grid-cols-1 gap-2">
                    </div>
            </div>

            <div id="map-view" class="bg-pip-bg flex-grow">
                <canvas id="map-canvas" class="map-canvas flex-grow"></canvas>
                <div id="map-info" class="text-center py-2 bg-pip-dark border-t border-pip-dim">
                    Aktuelle Position: <span id="current-location">Wasteland</span>
                </div>
            </div>
            
            <div id="combat-view" class="bg-pip-bg flex-col justify-between hidden">
                <div>
                    <h2 class="text-xl border-b border-pip-dim mb-4">KAMPF!</h2>
                    <p id="combat-message" class="mb-4"></p>
                    <div id="enemy-stats" class="mb-4 p-2 border border-pip-dim"></div>
                    <div id="player-combat-stats" class="p-2 border border-pip-dim"></div>
                </div>
                <div id="combat-actions" class="flex justify-around mt-4 border-t border-pip-dim pt-4">
                    <button class="pip-nav-btn" onclick="resolveCombat('attack')">ANGREIFEN</button>
                    <button class="pip-nav-btn" onclick="resolveFlee()">FLÜCHTEN</button>
                </div>
            </div>

            <div id="log-view" class="bg-pip-bg flex-col overflow-y-auto">
                <h2 class="text-xl border-b border-pip-dim mb-4">MELDUNGEN</h2>
                <div id="log-entries" class="flex-grow">
                    </div>
            </div>
            
            <div id="wiki-view" class="bg-pip-bg flex-col overflow-y-auto">
                <h2 class="text-xl border-b border-pip-dim mb-4">WASTELAND WIKI</h2>
                <div id="wiki-content">
                    <p>Wähle eine Kategorie, um mehr zu erfahren.</p>
                </div>
            </div>

        </div>

        <div class="pip-footer flex justify-between">
            <div class="flex space-x-4">
                <button onclick="saveGame()" class="pip-nav-btn">SPEICHERN (Lokal)</button>
                <button onclick="initNewGame()" class="pip-nav-btn">NEUES SPIEL</button>
                <button onclick="quitGame()" class="pip-nav-btn">BEENDEN</button>
            </div>
            <span id="time-display">20:00h | Tag 1</span>
        </div>
        
        <div id="city-modal" class="pip-modal">
            <div class="bg-pip-dark p-6 border-2 border-pip-green max-w-sm w-full">
                <h3 class="text-2xl mb-4" id="city-modal-title">Eintritt in die Stadt</h3>
                <p id="city-modal-message" class="mb-6">Möchten Sie die Stadt betreten?</p>
                <div class="flex justify-around">
                    <button class="pip-nav-btn" onclick="confirmCityEntry(true)">Betreten</button>
                    <button class="pip-nav-btn" onclick="confirmCityEntry(false)">Bleiben</button>
                </div>
            </div>
        </div>
        
        <div id="game-over-modal" class="pip-modal">
            <div class="bg-pip-dark p-8 border-2 border-pip-green text-center">
                <h3 class="text-4xl text-red-500 mb-4">SPIEL VORBEI!</h3>
                <p class="mb-6">Ihre Reise endet hier in der Ödnis.</p>
                <button class="pip-nav-btn" onclick="location.reload()">Neustart</button>
            </div>
        </div>
        
        <div id="buy-modal" class="pip-modal">
            <div class="bg-pip-dark p-6 border-2 border-pip-green max-w-lg w-full">
                <h3 class="text-2xl mb-4 border-b border-pip-dim" id="buy-modal-title">Händler: General Store</h3>
                <div id="buy-list" class="h-64 overflow-y-auto mb-4 grid grid-cols-2 gap-4">
                    </div>
                <div class="flex justify-between items-center mt-4 border-t border-pip-dim pt-4">
                    <p>Ihre Kronkorken: <span id="buy-caps-display">0</span></p>
                    <button class="pip-nav-btn" onclick="document.getElementById('buy-modal').style.display='none'; switchView('map')">Verlassen</button>
                </div>
            </div>
        </div>
        
    </div>

    <script>

        // =========================================================================
        // GLOBALE ZUSTÄNDE, KONSTANTEN & DATENBANK
        // =========================================================================

        const MAP_SIZE = 40; // 40x40 Map
        const TILE_SIZE = 16; // Pixelgröße für ein Tile auf dem Canvas

        let gameState = {};
        let initialGameState = {};
        let auth = null; // Unnötige Variable entfernt
        
        // Element-Referenzen
        const els = {
            screen: document.getElementById('pip-screen'),
            canvas: document.getElementById('map-canvas'),
            ctx: document.getElementById('map-canvas').getContext('2d'),
            
            // Displays
            health: document.getElementById('health-display'),
            caps: document.getElementById('caps-display'),
            level: document.getElementById('level-display'),
            exp: document.getElementById('exp-display'),
            expNeeded: document.getElementById('exp-needed-display'),
            statPoints: document.getElementById('stat-points-display'),
            playerName: document.getElementById('player-name-display'),
            timeDisplay: document.getElementById('time-display'),
            currentLocation: document.getElementById('current-location'),
            
            // Views
            statView: document.getElementById('stat-view'),
            itemView: document.getElementById('item-view'),
            mapView: document.getElementById('map-view'),
            combatView: document.getElementById('combat-view'),
            logView: document.getElementById('log-view'),
            wikiView: document.getElementById('wiki-view'),
            
            // Containers
            statList: document.getElementById('stat-list'),
            itemList: document.getElementById('item-list'),
            logEntries: document.getElementById('log-entries'),
            specialPoints: document.getElementById('special-points-container'),
            
            // Modals
            cityModal: document.getElementById('city-modal'),
            gameOverModal: document,getElementById('game-over-modal'),
            buyModal: document.getElementById('buy-modal'),

            // Navigation
            navStat: document.getElementById('nav-stat'),
            navItem: document.getElementById('nav-item'),
            navMap: document.getElementById('nav-map'),
            navLog: document.getElementById('nav-log'),
            navWiki: document.getElementById('nav-wiki'),
        };

        const MAP_TILES = {
            arid: { color: 'var(--color-arid)', code: 'A', traversable: true, encounter: 0.1 },
            path: { color: 'var(--color-path)', code: 'P', traversable: true, encounter: 0.05 },
            rock: { color: 'var(--color-rock)', code: 'R', traversable: false, encounter: 0 },
            water: { color: 'var(--color-water)', code: 'W', traversable: false, encounter: 0 },
            city: { color: 'var(--color-city)', code: 'C', traversable: true, encounter: 0 },
        };
        
        const SPECIAL_STATS = ['Strength', 'Perception', 'Endurance', 'Charisma', 'Intelligence', 'Agility', 'Luck'];
        const SKILLS = ['Small Guns', 'Melee', 'Barter', 'Medicine', 'Repair', 'Survival', 'Sneak'];

        const INITIAL_INVENTORY = [
            { name: 'Pipe Pistol', type: 'Weapon', damage: 5, value: 50, count: 1 },
            { name: 'Stimpak', type: 'Consumable', effect: 'Heal 25', value: 30, count: 2 },
            { name: 'Dirty Water', type: 'Consumable', effect: 'Heal 5, Rads +5', value: 5, count: 3 },
        ];
        
        const MONSTER_TEMPLATES = [
            { name: 'Radscorp', hp: 20, damage: 5, exp: 25, caps: 10 },
            { name: 'Raider', hp: 30, damage: 8, exp: 40, caps: 25 },
            { name: 'Giant Rat', hp: 15, damage: 3, exp: 15, caps: 5 },
        ];
        
        const CITIES = [
            { name: "Megaton", x: 5, y: 5, vendor: [{name: 'Stimpak', value: 50}, {name: 'Pipe Rifle', value: 150}] },
            { name: "Rivet City", x: 30, y: 30, vendor: [{name: 'Advanced Armor', value: 500}, {name: 'Water', value: 10}] },
        ];
        
        // =========================================================================
        // HILFSFUNKTIONEN
        // =========================================================================

        /**
         * Protokolliert eine Nachricht im Log-Fenster.
         * @param {string} message - Die anzuzeigende Nachricht.
         * @param {string} [tailwindClass=""] - Tailwind-Klassen für die Formatierung.
         */
        function log(message, tailwindClass = "") {
            const entry = document.createElement('div');
            const time = new Date().toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
            
            entry.className = `log-entry ${tailwindClass}`;
            entry.innerHTML = `<span class="text-pip-dim">[${time}]</span> ${message}`;
            
            els.logEntries.prepend(entry);
            
            // Log auf 50 Einträge begrenzen
            while (els.logEntries.children.length > 50) {
                els.logEntries.lastChild.remove();
            }
        }
        
        /**
         * Erzeugt eine zufällige, offene Map.
         * @returns {Array<Array<string>>} Die Map.
         */
        function generateMap() {
            const map = Array(MAP_SIZE).fill(0).map(() => Array(MAP_SIZE).fill('A')); // Alles ist Arid
            
            // Pfade (Path)
            for (let i = 0; i < 10; i++) {
                let x = Math.floor(Math.random() * MAP_SIZE);
                let y = Math.floor(Math.random() * MAP_SIZE);
                for (let j = 0; j < 10; j++) {
                    map[y][x] = 'P';
                    x = Math.max(0, Math.min(MAP_SIZE - 1, x + (Math.random() > 0.5 ? 1 : -1)));
                    y = Math.max(0, Math.min(MAP_SIZE - 1, y + (Math.random() > 0.5 ? 1 : -1)));
                }
            }
            
            // Felsen (Rock)
            for (let i = 0; i < 50; i++) {
                const x = Math.floor(Math.random() * MAP_SIZE);
                const y = Math.floor(Math.random() * MAP_SIZE);
                if (map[y][x] !== 'P') {
                    map[y][x] = 'R';
                }
            }
            
            // Städte
            CITIES.forEach(city => {
                map[city.y][city.x] = 'C';
            });
            
            return map;
        }

        /**
         * Berechnet den aktuellen Wert einer Statistik basierend auf SPECIAL.
         * @param {string} skillName - Der Name des Skills.
         * @returns {number} Der berechnete Skill-Wert.
         */
        function getSkillValue(skillName) {
            let baseValue = 0;
            let specialStat = '';

            switch (skillName) {
                case 'Small Guns':
                    specialStat = 'Agility';
                    baseValue = 10;
                    break;
                case 'Melee':
                    specialStat = 'Strength';
                    baseValue = 10;
                    break;
                case 'Barter':
                    specialStat = 'Charisma';
                    baseValue = 10;
                    break;
                case 'Medicine':
                    specialStat = 'Intelligence';
                    baseValue = 10;
                    break;
                case 'Repair':
                    specialStat = 'Intelligence';
                    baseValue = 10;
                    break;
                case 'Survival':
                    specialStat = 'Endurance';
                    baseValue = 10;
                    break;
                case 'Sneak':
                    specialStat = 'Agility';
                    baseValue = 10;
                    break;
                default:
                    return 0;
            }

            return baseValue + (gameState.stats.special[specialStat] * 2) + gameState.stats.skills[skillName];
        }


        // =========================================================================
        // ZUSTANDSVERWALTUNG & INITIALISIERUNG
        // =========================================================================

        /**
         * Setzt den initialen Spielzustand.
         */
        function setupInitialGameState() {
            const initialMap = generateMap();
            
            initialGameState = {
                initialized: true,
                isGameOver: false,
                inDialog: false,
                currentView: 'stat',
                
                // Zeit
                day: 1,
                time: 8 * 60, // 8:00 Uhr in Minuten (8 * 60)
                
                // Map
                map: initialMap,
                playerPosition: { x: 1, y: 1 },
                currentLocationName: 'Wasteland',
                
                // Kampf
                inCombat: false,
                currentEnemy: null,
                
                // Charakter
                stats: {
                    health: 100,
                    maxHealth: 100,
                    caps: 100,
                    level: 1,
                    exp: 0,
                    expNeeded: 100,
                    statPoints: 5, // Anfängliche Stat-Punkte
                    special: {
                        Strength: 1, Perception: 1, Endurance: 1, Charisma: 1, 
                        Intelligence: 1, Agility: 1, Luck: 1
                    },
                    tempSpecial: {
                        Strength: 1, Perception: 1, Endurance: 1, Charisma: 1, 
                        Intelligence: 1, Agility: 1, Luck: 1
                    },
                    skills: {
                        'Small Guns': 0, 'Melee': 0, 'Barter': 0, 'Medicine': 0, 
                        'Repair': 0, 'Survival': 0, 'Sneak': 0
                    }
                },
                inventory: INITIAL_INVENTORY.map(i => ({...i})),
            };
            
            gameState = JSON.parse(JSON.stringify(initialGameState));
            log("Willkommen im Pip-Boy 3000 Mk-V RPG!", "text-green-400");
            log("Die Firebase Cloud-Speicherfunktion wurde entfernt. Es wird nur lokal gespeichert.", "text-yellow-500");
            
            updateUI();
        }

        /**
         * Versucht, das Spiel aus dem lokalen Speicher zu laden.
         */
        function loadGame() {
            const savedState = localStorage.getItem('pipboy_save_01');
            if (savedState) {
                try {
                    gameState = JSON.parse(savedState);
                    log("Spiel erfolgreich aus dem lokalen Speicher geladen.", "text-green-400");
                    return true;
                } catch(e) {
                    log("FEHLER: Gespeicherte Daten sind korrupt.", "text-red-500");
                    return false;
                }
            }
            return false;
        }

        /**
         * Speichert den aktuellen Spielzustand im lokalen Speicher.
         */
        function saveGame() {
            // Speicherung nur lokal (localStorage)
            try {
                localStorage.setItem('pipboy_save_01', JSON.stringify(gameState));
                log("Spiel erfolgreich lokal gespeichert.", "text-green-500");
            } catch(e) {
                log("FEHLER: Lokales Speichern fehlgeschlagen: " + e.message, "text-red-500");
            }
        }
        
        /**
         * Initialisiert ein neues Spiel.
         */
        function initNewGame() {
            if (confirm("Sind Sie sicher, dass Sie ein neues Spiel starten möchten? Der aktuelle Fortschritt geht verloren (lokale Speicherung).")) {
                setupInitialGameState();
                switchView('stat');
            }
        }
        
        /**
         * Beendet das Spiel (reload)
         */
        function quitGame() {
            if (confirm("Möchten Sie das Spiel wirklich beenden?")) {
                // Ein einfacher Weg, den Zustand zurückzusetzen
                window.location.reload(); 
            }
        }

        // =========================================================================
        // HAUPT-LOOP & UI-RENDERING
        // =========================================================================

        /**
         * Zeichnet die Map auf das Canvas.
         */
        function draw() {
            const { ctx, canvas } = els;
            const { map, playerPosition: pos } = gameState;
            const radius = 5; // Sichtradius
            
            // Klare Canvas
            ctx.fillStyle = MAP_TILES.fog.color;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const cellW = canvas.width / (radius * 2 + 1);
            const cellH = canvas.height / (radius * 2 + 1);
            
            for (let y = -radius; y <= radius; y++) {
                for (let x = -radius; x <= radius; x++) {
                    const mapX = pos.x + x;
                    const mapY = pos.y + y;
                    
                    if (mapX >= 0 && mapX < MAP_SIZE && mapY >= 0 && mapY < MAP_SIZE) {
                        const tileCode = map[mapY][mapX];
                        const tile = MAP_TILES[Object.keys(MAP_TILES).find(key => MAP_TILES[key].code === tileCode)];
                        
                        // Zeichne Tile
                        ctx.fillStyle = tile.color;
                        ctx.fillRect(
                            (x + radius) * cellW, 
                            (y + radius) * cellH, 
                            cellW, 
                            cellH
                        );
                        
                        // Zeichne Tile Code (optional, für Debug)
                        ctx.fillStyle = '#00000055'; // Leicht transparentes Schwarz
                        ctx.fillText(tileCode, 
                            (x + radius) * cellW + cellW * 0.4, 
                            (y + radius) * cellH + cellH * 0.6
                        );
                    }
                }
            }
            
            // Zeichne Spieler in der Mitte
            ctx.fillStyle = '#ff0000'; // Rot
            ctx.beginPath();
            ctx.arc(
                canvas.width / 2, 
                canvas.height / 2, 
                cellW * 0.3, 
                0, 
                Math.PI * 2
            );
            ctx.fill();
            
            // Rand um die Map
            ctx.strokeStyle = var(--pip-green);
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);
        }

        /**
         * Aktualisiert die Benutzeroberfläche basierend auf dem gameState.
         */
        function updateUI() {
            const { stats, level, exp, expNeeded, statPoints } = gameState.stats;
            const { health, maxHealth, caps } = gameState.stats;
            
            // Header und Grund-Infos
            els.health.textContent = `HP: ${health}/${maxHealth}`;
            els.caps.textContent = `CAPS: ${caps}`;
            els.level.textContent = level;
            els.exp.textContent = exp;
            els.expNeeded.textContent = expNeeded;
            els.statPoints.textContent = statPoints;
            
            // Zeit
            const totalMinutes = gameState.time + (gameState.day - 1) * 24 * 60;
            const hours = Math.floor(gameState.time / 60) % 24;
            const minutes = gameState.time % 60;
            const timeStr = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}h`;
            els.timeDisplay.textContent = `${timeStr} | Tag ${gameState.day}`;

            // Map-Info
            els.currentLocation.textContent = gameState.currentLocationName;
            
            // STAT View
            updateStatView();
            
            // ITEM View
            updateItemView();

            // Aktuelle Ansicht neu rendern
            if (gameState.currentView === 'map') draw();
        }

        /**
         * Aktualisiert die STAT-Ansicht.
         */
        function updateStatView() {
            const { special, tempSpecial, statPoints } = gameState.stats;
            
            // S.P.E.C.I.A.L. Punkte Container
            els.specialPoints.innerHTML = `
                <p class="text-lg font-bold mb-2">S.P.E.C.I.A.L. Punkte verfügbar: 
                    <span class="${statPoints > 0 ? 'text-green-500' : 'text-pip-dim'}">${statPoints}</span>
                </p>
            `;
            
            // S.P.E.C.I.A.L. Stats
            let specialHTML = '<div class="grid grid-cols-2 gap-2 mb-6">';
            SPECIAL_STATS.forEach(stat => {
                const value = tempSpecial[stat];
                const buttonDisabled = statPoints === 0 || value >= 10;
                specialHTML += `
                    <div class="stat-line">
                        <span>${stat.toUpperCase()}: ${value}</span>
                        <button onclick="increaseTempStat('${stat}')" ${buttonDisabled ? 'disabled' : ''}>+</button>
                    </div>
                `;
            });
            specialHTML += '</div>';
            
            // Apply Button
            const hasUnappliedPoints = SPECIAL_STATS.some(stat => tempSpecial[stat] !== special[stat]);
            specialHTML += `
                <div class="text-center mt-4">
                    <button class="pip-nav-btn ${hasUnappliedPoints ? 'hover:bg-green-500' : 'opacity-50 cursor-not-allowed'}" 
                            onclick="applyStatPoint()" ${hasUnappliedPoints ? '' : 'disabled'}>
                        Punkte Anwenden
                    </button>
                </div>
            `;
            
            els.statList.innerHTML = specialHTML;
            
            // Skills
            let skillHTML = '<h3 class="text-xl border-b border-pip-dim mt-6 mb-4">SKILLS</h3><div class="grid grid-cols-2 gap-2">';
            SKILLS.forEach(skill => {
                const value = getSkillValue(skill); // Skill + SPECIAL-Bonus
                skillHTML += `
                    <div class="skill-line">
                        <span>${skill}: ${value}</span>
                    </div>
                `;
            });
            skillHTML += '</div>';

            els.statList.innerHTML += skillHTML;
        }

        /**
         * Aktualisiert die ITEM-Ansicht.
         */
        function updateItemView() {
            let itemHTML = '';
            gameState.inventory.forEach(item => {
                itemHTML += `
                    <div class="item-line p-2 border border-pip-dim flex-col">
                        <div class="flex justify-between">
                            <span class="font-bold">${item.name} x${item.count}</span>
                            <span>Typ: ${item.type}</span>
                        </div>
                        <div class="text-sm mt-1 flex justify-between">
                            <span>Effekt: ${item.effect || `Schaden: ${item.damage}`}</span>
                            <button class="text-sm bg-pip-dim px-2 hover:bg-pip-green hover:text-pip-dark" 
                                    onclick="useItem('${item.name}')">
                                BENUTZEN
                            </button>
                        </div>
                    </div>
                `;
            });
            els.itemList.innerHTML = itemHTML || '<p>Inventar ist leer.</p>';
        }

        // =========================================================================
        // SPIELMECHANIKEN
        // =========================================================================

        /**
         * Erhöht einen temporären SPECIAL-Statistikwert.
         * @param {string} stat - Der Name der Statistik.
         */
        function increaseTempStat(stat) {
            if (gameState.stats.statPoints > 0 && gameState.stats.tempSpecial[stat] < 10) {
                gameState.stats.tempSpecial[stat]++;
                gameState.stats.statPoints--;
                updateUI();
            }
        }
        
        /**
         * Wendet die temporären SPECIAL-Werte auf die permanenten Werte an.
         */
        function applyStatPoint() {
            const { special, tempSpecial } = gameState.stats;
            let pointsSpent = 0;
            
            SPECIAL_STATS.forEach(stat => {
                pointsSpent += tempSpecial[stat] - special[stat];
                special[stat] = tempSpecial[stat];
            });

            // Der Logikfehler in der ursprünglichen Implementierung:
            // Wenn man hier pointsSpent von statPoints abziehen würde, 
            // würde man doppelt abziehen, da increaseTempStat() dies schon tut.
            // Die `tempSpecial`-Logik ist als "Preview" gedacht. Da ich es jetzt 
            // so implementiert habe, dass increaseTempStat die Punkte direkt 
            // abzieht, muss hier nur zugewiesen werden.
            
            log(`S.P.E.C.I.A.L.-Punkte angewendet.`, 'text-blue-400');
            updateUI();
        }

        /**
         * Bewegt den Spieler auf der Karte und löst Events aus.
         * @param {number} dx - Änderung der X-Koordinate (-1, 0, 1).
         * @param {number} dy - Änderung der Y-Koordinate (-1, 0, 1).
         */
        function movePlayer(dx, dy) {
            if (gameState.inDialog || gameState.inCombat || gameState.isGameOver) return;
            
            const newX = gameState.playerPosition.x + dx;
            const newY = gameState.playerPosition.y + dy;
            
            // Check Map Grenzen
            if (newX < 0 || newX >= MAP_SIZE || newY < 0 || newY >= MAP_SIZE) {
                log("Sie sind an den Rand der bekannten Welt gestoßen.", "text-red-500");
                return;
            }
            
            const tileCode = gameState.map[newY][newX];
            const tile = MAP_TILES[Object.keys(MAP_TILES).find(key => MAP_TILES[key].code === tileCode)];
            
            // Check Traversable
            if (!tile.traversable) {
                log("Sie können diesen felsigen oder wässrigen Weg nicht nehmen.", "text-red-500");
                return;
            }
            
            gameState.playerPosition.x = newX;
            gameState.playerPosition.y = newY;
            
            // Time Advance
            gameState.time += 15; // 15 Minuten pro Zug
            if (gameState.time >= 24 * 60) {
                gameState.time = gameState.time % (24 * 60);
                gameState.day++;
                log(`Ein neuer Tag bricht an: Tag ${gameState.day}`, "text-yellow-400");
            }
            
            // City Event
            const city = CITIES.find(c => c.x === newX && c.y === newY);
            if (city) {
                gameState.currentLocationName = city.name;
                gameState.inDialog = true;
                els.cityModal.style.display = 'flex';
                document.getElementById('city-modal-title').textContent = city.name;
                document.getElementById('city-modal-message').textContent = `Sie sind in ${city.name} angekommen. Möchten Sie die Stadt betreten und handeln?`;
            } else {
                gameState.currentLocationName = 'Wasteland';
                
                // Combat Event (Nur im Ödland und auf traversierbaren Kacheln)
                if (Math.random() < tile.encounter && tile.encounter > 0) {
                    startCombat();
                }
            }

            updateUI();
        }

        /**
         * Bestätigt den Eintritt in eine Stadt.
         * @param {boolean} enter - Ob der Spieler die Stadt betreten möchte.
         */
        function confirmCityEntry(enter) {
            els.cityModal.style.display = 'none';
            gameState.inDialog = false;
            
            if (enter) {
                const city = CITIES.find(c => c.x === gameState.playerPosition.x && c.y === gameState.playerPosition.y);
                log(`Sie betreten ${city.name}.`, "text-blue-400");
                showBuyMenu(city);
            } else {
                log(`Sie bleiben außerhalb der Stadtmauern.`, "text-yellow-400");
                switchView('map');
            }
        }
        
        /**
         * Startet einen Kampf.
         */
        function startCombat() {
            gameState.inCombat = true;
            // Wähle zufälligen Gegner
            const enemyTemplate = MONSTER_TEMPLATES[Math.floor(Math.random() * MONSTER_TEMPLATES.length)];
            gameState.currentEnemy = { ...enemyTemplate, maxHp: enemyTemplate.hp };
            
            log(`Sie wurden von einem ${gameState.currentEnemy.name} angegriffen!`, "text-red-500");
            
            // Setze Combat-View auf
            document.getElementById('combat-message').textContent = `Ein ${gameState.currentEnemy.name} steht Ihnen gegenüber!`;
            updateCombatUI();
            switchView('combat');
        }
        
        /**
         * Aktualisiert die Combat-View-Elemente.
         */
        function updateCombatUI() {
            const enemy = gameState.currentEnemy;
            const player = gameState.stats;
            
            // Gegner-Stats
            document.getElementById('enemy-stats').innerHTML = `
                <span class="font-bold">${enemy.name}</span><br>
                HP: ${enemy.hp}/${enemy.maxHp} | Schaden: ${enemy.damage}
            `;
            
            // Spieler-Stats (für den Kampf)
            document.getElementById('player-combat-stats').innerHTML = `
                <span class="font-bold">Ihre Stats</span><br>
                HP: ${player.health}/${player.maxHealth} | Waffe: ${gameState.inventory.find(i => i.type === 'Weapon')?.name || 'Fists'}
            `;
        }
        
        /**
         * Führt einen Kampfzug aus.
         * @param {string} action - 'attack' oder 'flee'.
         */
        function resolveCombat(action) {
            if (gameState.isGameOver || !gameState.inCombat) return;

            const enemy = gameState.currentEnemy;
            const player = gameState.stats;
            const playerWeapon = gameState.inventory.find(i => i.type === 'Weapon');
            
            // 1. Spieler greift an
            const playerDamage = playerWeapon ? playerWeapon.damage + Math.floor(getSkillValue('Small Guns') / 10) : 2;
            enemy.hp -= playerDamage;
            log(`Sie treffen den ${enemy.name} für ${playerDamage} Schaden.`, 'text-green-500');
            
            if (enemy.hp <= 0) {
                // Gegner besiegt
                log(`${enemy.name} besiegt! Sie erhalten ${enemy.exp} EXP und ${enemy.caps} Kronkorken.`, 'text-yellow-400');
                player.exp += enemy.exp;
                player.caps += enemy.caps;
                checkLevelUp();
                
                gameState.inCombat = false;
                gameState.currentEnemy = null;
                switchView('map'); // Zurück zur Map
                return;
            }
            
            // 2. Gegner greift an
            player.health -= enemy.damage;
            log(`${enemy.name} schlägt zurück und verursacht ${enemy.damage} Schaden.`, 'text-red-500');
            
            if (player.health <= 0) {
                // Spieler besiegt
                gameOver();
                return;
            }
            
            updateCombatUI();
            updateUI();
        }

        /**
         * Versucht, aus dem Kampf zu fliehen.
         */
        function resolveFlee() {
            // Fluchtchance basiert auf Agility und Luck (Beispiel)
            const fleeChance = gameState.stats.tempSpecial.Agility * 5 + gameState.stats.tempSpecial.Luck * 2;
            
            if (Math.random() * 100 < fleeChance) {
                log("Sie sind erfolgreich geflohen!", 'text-green-500');
                gameState.inCombat = false;
                gameState.currentEnemy = null;
                switchView('map');
            } else {
                log("Flucht fehlgeschlagen! Der Gegner greift an.", 'text-red-500');
                // Erzwungener Gegnerzug
                const enemy = gameState.currentEnemy;
                gameState.stats.health -= enemy.damage;
                log(`${enemy.name} nutzt Ihre Ablenkung und verursacht ${enemy.damage} Schaden.`, 'text-red-500');
                
                if (gameState.stats.health <= 0) {
                    gameOver();
                    return;
                }
                updateCombatUI();
                updateUI();
            }
        }
        
        /**
         * Verwaltet Level-Up-Logik.
         */
        function checkLevelUp() {
            if (gameState.stats.exp >= gameState.stats.expNeeded) {
                gameState.stats.exp -= gameState.stats.expNeeded;
                gameState.stats.level++;
                gameState.stats.expNeeded = Math.floor(gameState.stats.expNeeded * 1.5);
                gameState.stats.statPoints += 2; // Punkte für Level-Up
                
                log(`LEVEL UP! Sie sind jetzt Level ${gameState.stats.level}!`, 'text-green-400 font-bold');
                
                // Setze temporäre SPECIAL-Werte zurück, um die neuen Punkte anzuzeigen
                gameState.stats.tempSpecial = { ...gameState.stats.special }; 
                
                // Automatisches Umschalten zur Stat-Ansicht, um Punkte zu vergeben
                switchView('stat'); 
            }
        }
        
        /**
         * Führt die Logik für Game Over aus.
         */
        function gameOver() {
            gameState.isGameOver = true;
            gameState.inCombat = false;
            els.gameOverModal.style.display = 'flex';
            log("Sie sind gestorben.", 'text-red-500 font-bold');
        }
        
        /**
         * Zeigt das Handelsmenü an.
         * @param {object} city - Das Stadtobjekt mit Händler-Items.
         */
        function showBuyMenu(city) {
            const buyListEl = document.getElementById('buy-list');
            const buyCapsDisplayEl = document.getElementById('buy-caps-display');
            const titleEl = document.getElementById('buy-modal-title');
            
            titleEl.textContent = `Händler: ${city.name} Store`;
            buyCapsDisplayEl.textContent = gameState.stats.caps;
            
            let buyHTML = '';
            city.vendor.forEach(item => {
                const isAffordable = gameState.stats.caps >= item.value;
                buyHTML += `
                    <div class="p-2 border border-pip-dim flex justify-between items-center ${!isAffordable ? 'opacity-50' : ''}">
                        <span>${item.name} (${item.value} Caps)</span>
                        <button class="pip-nav-btn text-sm" onclick="buyItem('${item.name}', ${item.value}, '${city.name}')" ${!isAffordable ? 'disabled' : ''}>Kaufen</button>
                    </div>
                `;
            });
            
            buyListEl.innerHTML = buyHTML;
            els.buyModal.style.display = 'flex';
            gameState.inDialog = true;
        }

        /**
         * Führt den Kauf eines Items durch.
         * @param {string} itemName - Name des Items.
         * @param {number} value - Preis des Items.
         * @param {string} cityName - Name der Stadt (für Log).
         */
        function buyItem(itemName, value, cityName) {
            if (gameState.stats.caps >= value) {
                gameState.stats.caps -= value;
                
                // Item zum Inventar hinzufügen (angenommen, es ist ein einfacher Item-Typ)
                const existingItem = gameState.inventory.find(i => i.name === itemName);
                if (existingItem) {
                    existingItem.count++;
                } else {
                    // Füge ein Standard-Item hinzu (müsste idealerweise aus einer zentralen Item-Datenbank kommen)
                    const newItem = INITIAL_INVENTORY.find(i => i.name === itemName) || { name: itemName, type: 'Misc', value: value, count: 1 };
                    gameState.inventory.push({...newItem, count: 1});
                }

                log(`Sie haben ${itemName} in ${cityName} für ${value} Caps gekauft.`, 'text-blue-400');
                updateUI();
                
                // Modal neu laden, um Caps-Anzeige und Buttons zu aktualisieren
                const city = CITIES.find(c => c.name === cityName);
                showBuyMenu(city); 

            } else {
                log(`Nicht genügend Kronkorken, um ${itemName} zu kaufen.`, 'text-red-500');
            }
        }
        
        /**
         * Benutzt ein Item aus dem Inventar.
         * @param {string} itemName - Der Name des zu verwendenden Items.
         */
        function useItem(itemName) {
            const itemIndex = gameState.inventory.findIndex(i => i.name === itemName);
            if (itemIndex === -1) return;
            
            const item = gameState.inventory[itemIndex];
            
            if (item.type === 'Consumable') {
                log(`Sie benutzen ${item.name}.`, 'text-blue-400');
                
                // Simples Effekt-Handling (könnte viel komplexer sein)
                if (item.effect.includes('Heal')) {
                    const healAmount = parseInt(item.effect.match(/Heal (\d+)/)[1]);
                    gameState.stats.health = Math.min(gameState.stats.maxHealth, gameState.stats.health + healAmount);
                }
                
                // Verringere Anzahl
                item.count--;
                if (item.count <= 0) {
                    gameState.inventory.splice(itemIndex, 1);
                }
                
            } else if (item.type === 'Weapon') {
                log(`Sie rüsten ${item.name} aus.`, 'text-blue-400');
                // In diesem simplen System ist die Waffe immer ausgerüstet
            } else {
                 log(`${item.name} kann nicht benutzt werden.`, 'text-red-500');
                 return;
            }
            
            updateUI();
        }


        // =========================================================================
        // VIEW MANAGEMENT & LAYOUT
        // =========================================================================

        /**
         * Wechselt die aktive Ansicht (STAT, ITEM, MAP, LOG, COMBAT).
         * @param {string} viewName - Name der Ansicht.
         */
        function switchView(viewName) {
            // Alle Ansichten ausblenden
            Object.values(els).filter(el => el.id && el.id.endsWith('-view')).forEach(el => {
                el.style.display = 'none';
                el.classList.remove('flex'); // Remove flex for standard views
                el.classList.add('hidden'); // Use Tailwind hidden for non-flex
            });

            // Alle Nav-Buttons deaktivieren
            Object.values(els).filter(el => el.id && el.id.startsWith('nav-')).forEach(el => {
                el.classList.remove('active');
            });
            
            // Aktuelle Ansicht anzeigen
            const currentViewEl = document.getElementById(`${viewName}-view`);
            if (currentViewEl) {
                // Combat View und Map View benötigen 'flex'
                if (viewName === 'map' || viewName === 'combat') {
                    currentViewEl.classList.remove('hidden');
                    currentViewEl.classList.add('flex');
                } else {
                    currentViewEl.classList.remove('hidden');
                    currentViewEl.style.display = 'block';
                }
            }

            // Aktiven Nav-Button setzen
            const navButtonEl = document.getElementById(`nav-${viewName}`);
            if (navButtonEl) {
                navButtonEl.classList.add('active');
            }
            
            gameState.currentView = viewName;
            
            // Map muss neu gezeichnet werden, wenn sie aktiv wird
            if (viewName === 'map') {
                handleResize(); // Stellt sicher, dass das Canvas skaliert wird
                draw(); 
            }
            
            updateUI(); // Stellt sicher, dass Daten aktuell sind
        }
        
        /**
         * Zeigt die Wiki-Ansicht an und befüllt sie (Platzhalter).
         */
        function showWiki() {
            const wikiContentEl = document.getElementById('wiki-content');
            wikiContentEl.innerHTML = `
                <h3 class="text-xl mb-2">SPIELREGELN</h3>
                <p><strong>Ziel:</strong> Überlebe in der Ödnis, sammle Kronkorken (Caps) und werde stärker.</p>
                <p><strong>S.P.E.C.I.A.L.:</strong> Bestimmt deine Fähigkeiten. Erhöhe die Werte, um bessere Skill-Boni zu erhalten.</p>
                <p><strong>Kampf:</strong> Kämpfe werden rundenbasiert automatisch abgewickelt, basierend auf deinen Werten.</p>
                <h3 class="text-xl mb-2 mt-4">KARTENLEGENDE</h3>
                <ul>
                    <li><span style="color: var(--color-arid);">◼</span> Arid (Ödland)</li>
                    <li><span style="color: var(--color-path);">◼</span> Path (Weg)</li>
                    <li><span style="color: var(--color-rock);">◼</span> Rock (Fels, nicht passierbar)</li>
                    <li><span style="color: var(--color-city);">◼</span> City (Stadt/Siedlung)</li>
                    <li><span style="color: #ff0000;">●</span> Spielerposition</li>
                </ul>
            `;
            switchView('wiki');
        }

        /**
         * Stellt sicher, dass das Canvas im Container skaliert wird
         */
        function handleResize() {
            const container = els.mapView;
            if (!container) return; 

            // Stelle sicher, dass die Kantenlänge des Canvas dem kleineren Maß entspricht
            const size = Math.min(container.clientWidth, container.clientHeight);
            
            // Setze CSS-Höhe/Breite auf die tatsächliche Rendergröße
            els.canvas.style.width = `${size}px`;
            els.canvas.style.height = `${size}px`;
            
            // Setze Canvas-Attribute für die interne Auflösung
            els.canvas.width = size;
            els.canvas.height = size;
            
            // Schriftgröße für Debug-Text auf der Map anpassen
            els.ctx.font = `${Math.floor(size / (5 * 2 + 1) * 0.4)}px VT323`; 
            
            if (gameState.currentView === 'map') {
                draw(); 
            }
            updateUI();
        }
        
        // =========================================================================
        // INITIALISIERUNG
        // =========================================================================
        
        function initializeApp() {
            // Lade Spiel oder starte neues Spiel
            if (!loadGame()) {
                setupInitialGameState();
            } else {
                // Setze temporäre Stats nach dem Laden zurück (wichtig)
                gameState.stats.tempSpecial = { ...gameState.stats.special }; 
            }

            // Sicherstellen, dass die UI-Elemente initialisiert und sichtbar sind
            switchView(gameState.currentView || 'stat'); 
            
            // Event Listener registrieren
            window.addEventListener('resize', handleResize);
            window.addEventListener('orientationchange', handleResize);
            
            // Tastatur Support (WASD und Pfeiltasten)
            window.addEventListener('keydown', (e) => {
                if(gameState.currentView !== 'map' || gameState.inDialog || gameState.isGameOver) return;
                
                if(e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') movePlayer(0, -1);
                else if(e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') movePlayer(0, 1);
                else if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') movePlayer(-1, 0);
                else if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') movePlayer(1, 0);
            });
            
            // Initialen Resize und Drawing aufrufen
            handleResize();
            updateUI();
        }

        // Starte die Anwendung, sobald das DOM bereit ist
        document.addEventListener('DOMContentLoaded', initializeApp);

    </script>
</body>
</html>
